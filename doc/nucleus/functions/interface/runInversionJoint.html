<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of runInversionJoint</title>
  <meta name="keywords" content="runInversionJoint">
  <meta name="description" content=" controls the joint inversion process to infer a pore size">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # nucleus --><!-- # functions --><!-- menu.html interface -->
<h1>runInversionJoint
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong> controls the joint inversion process to infer a pore size</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function runInversionJoint </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">runInversionJoint controls the joint inversion process to infer a pore size
distribution (PSD) from NMR and CPS data

 Syntax:
       runInversionJoint

 Inputs:
       none

 Outputs:
       none

 Example:
       runInversionJoint

 Other m-files required:
       checkIfInversionExists
       clearSingleAxis
       displayStatusText
       fcn_JointInvfixed
       fcn_JointInvfree
       fcn_JointInvshape
       getChi2
       getLambdaFromRMS
       getConstants
       getCornerNMRparameter
       getGeometryParameter
       getPartialSaturationMatrix    
       getSaturationFromPressureBatch
       onPushRun
       onPushShowHide
       onPushStop
       removeInversionFields    
       updateInfo
       updatePlotsJointInversion    
       updatePlotsLcurve</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>	 handles the callbacks to all RUN push buttons in both GUIs and</li><li><a href="../../../nucleus/callbacks/push/onPushShowHide.html" class="code" title="function onPushShowHide(src,~)">onPushShowHide</a>	 shows/hides the INFO column on the right side of NUCLEUSinv</li><li><a href="../../../nucleus/callbacks/push/onPushStop.html" class="code" title="function onPushStop(src,~)">onPushStop</a>	 recognizes that a STOP push button was pressed and resets the</li><li><a href="checkIfInversionExists.html" class="code" title="function [foundINV,N] = checkIfInversionExists(INVdata)">checkIfInversionExists</a>	 checks if any inversion result is stored inside</li><li><a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>	 clears an individual axis</li><li><a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>	 clears all axes of a given figure</li><li><a href="removeInversionFields.html" class="code" title="function data = removeInversionFields(data)">removeInversionFields</a>	 deletes all inversion result fields from NUCLEUSinv</li><li><a href="updateInfo.html" class="code" title="function updateInfo(src,~) %#ok<INUSD>">updateInfo</a>	 updates the information shown in all information list boxes</li><li><a href="updatePlotsJointInversion.html" class="code" title="function updatePlotsJointInversion">updatePlotsJointInversion</a>	 plots the joint-inversion results in NUCLEUSinv</li><li><a href="updatePlotsLcurve.html" class="code" title="function updatePlotsLcurve">updatePlotsLcurve</a>	</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>	 performs the "fixed" joint inversion using the RTD of</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>	 jointly estimates the pore size distribution and surface</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>	 performs the "shape" joint inversion using the RTD of</li><li><a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>	 the chi2 of a NMR fit (noise weighted error quality)</li><li><a href="../../../nucleus/functions/inversion/getLambdaFromLCurve.html" class="code" title="function index = getLambdaFromLCurve(rho,eta,plotit)">getLambdaFromLCurve</a>	 estimates the regularization parameter lambda according</li><li><a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>	 provides some physical constants to the forward calculation</li><li><a href="../../../nucleus/functions/modeling/getCornerNMRparameter.html" class="code" title="function out = getCornerNMRparameter(geometry,SatData,indt,imbdrain)">getCornerNMRparameter</a>	 calculates corner parameters (amplitude surface to</li><li><a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>	 calculates geometric parameters for the three possible</li><li><a href="../../../nucleus/functions/modeling/getPartialSaturationMatrix.html" class="code" title="function IPS = getPartialSaturationMatrix(SatData,indt,imbdrain)">getPartialSaturationMatrix</a>	 calculates the partial saturation matrix to be</li><li><a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>	 handles the callbacks to all RUN push buttons in both GUIs and</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function runInversionJoint</a>
0002 <span class="comment">%runInversionJoint controls the joint inversion process to infer a pore size</span>
0003 <span class="comment">%distribution (PSD) from NMR and CPS data</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Syntax:</span>
0006 <span class="comment">%       runInversionJoint</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Inputs:</span>
0009 <span class="comment">%       none</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Outputs:</span>
0012 <span class="comment">%       none</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% Example:</span>
0015 <span class="comment">%       runInversionJoint</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Other m-files required:</span>
0018 <span class="comment">%       checkIfInversionExists</span>
0019 <span class="comment">%       clearSingleAxis</span>
0020 <span class="comment">%       displayStatusText</span>
0021 <span class="comment">%       fcn_JointInvfixed</span>
0022 <span class="comment">%       fcn_JointInvfree</span>
0023 <span class="comment">%       fcn_JointInvshape</span>
0024 <span class="comment">%       getChi2</span>
0025 <span class="comment">%       getLambdaFromRMS</span>
0026 <span class="comment">%       getConstants</span>
0027 <span class="comment">%       getCornerNMRparameter</span>
0028 <span class="comment">%       getGeometryParameter</span>
0029 <span class="comment">%       getPartialSaturationMatrix</span>
0030 <span class="comment">%       getSaturationFromPressureBatch</span>
0031 <span class="comment">%       onPushRun</span>
0032 <span class="comment">%       onPushShowHide</span>
0033 <span class="comment">%       onPushStop</span>
0034 <span class="comment">%       removeInversionFields</span>
0035 <span class="comment">%       updateInfo</span>
0036 <span class="comment">%       updatePlotsJointInversion</span>
0037 <span class="comment">%       updatePlotsLcurve</span>
0038 
0039 <span class="comment">%</span>
0040 <span class="comment">% Subfunctions:</span>
0041 <span class="comment">%       none</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% MAT-files required:</span>
0044 <span class="comment">%       none</span>
0045 <span class="comment">%</span>
0046 <span class="comment">% See also: NUCLEUSinv</span>
0047 <span class="comment">% Author: Thomas Hiller</span>
0048 <span class="comment">% email: thomas.hiller[at]leibniz-liag.de</span>
0049 <span class="comment">% License: MIT License (at end)</span>
0050 
0051 <span class="comment">%------------- BEGIN CODE --------------</span>
0052 
0053 <span class="comment">%% get GUI handle and data</span>
0054 fig = findobj(<span class="string">'Tag'</span>,<span class="string">'INV'</span>);
0055 gui = getappdata(fig,<span class="string">'gui'</span>);
0056 data = getappdata(fig,<span class="string">'data'</span>);
0057 INVdata = getappdata(fig,<span class="string">'INVdata'</span>);
0058 
0059 <span class="comment">% check if there is any inversion results at all</span>
0060 foundINV = <a href="checkIfInversionExists.html" class="code" title="function [foundINV,N] = checkIfInversionExists(INVdata)">checkIfInversionExists</a>(INVdata);
0061 
0062 <span class="comment">%% if yes continue</span>
0063 <span class="keyword">if</span> foundINV    
0064     <span class="comment">% check which signals have been inverted before</span>
0065     <span class="comment">% (E0 is needed for Sat-normalization)</span>
0066     nINV = size(INVdata,1);
0067     E0 = zeros(nINV,1);
0068     c = 0;
0069     <span class="keyword">for</span> i = 1:nINV
0070         <span class="keyword">if</span> isstruct(INVdata{i})
0071             c = c + 1;
0072             E0(i,1) = sum(INVdata{i}.results.invstd.E0);
0073             invlevels(c) = i; <span class="comment">%#ok&lt;*AGROW&gt;</span>
0074             invtype{c} = INVdata{i}.invstd.invtype;
0075             gatetype{c} = INVdata{i}.results.nmrproc.gatetype;
0076         <span class="keyword">end</span>
0077     <span class="keyword">end</span>    
0078     <span class="comment">% for &quot;fixed&quot; and &quot;shape&quot; inversion a RTD is needed</span>
0079     InvtypeIsOK = false;
0080     <span class="keyword">switch</span> data.invjoint.invtype
0081         <span class="keyword">case</span> {<span class="string">'fixed'</span>,<span class="string">'shape'</span>}
0082             <span class="keyword">switch</span> invtype{1}
0083                 <span class="keyword">case</span> {<span class="string">'ILA'</span>,<span class="string">'NNLS'</span>}
0084                     InvtypeIsOK = true;
0085                 <span class="keyword">otherwise</span>
0086                     <span class="comment">% nothing to do</span>
0087             <span class="keyword">end</span>
0088         <span class="keyword">otherwise</span>
0089             InvtypeIsOK = true;
0090     <span class="keyword">end</span>
0091     <span class="comment">% check if the gatetype is for all signals the same</span>
0092     GatetypeIsOK = false;
0093     <span class="keyword">if</span> numel(unique(gatetype)) == 1
0094         GatetypeIsOK = true;
0095     <span class="keyword">end</span>
0096     
0097     <span class="comment">% the pressure / saturation data</span>
0098     table = data.pressure.table;
0099     uselevel = cell2mat(table(:,1));
0100     tablelevels = 1:size(table,1);
0101     tablelevels = tablelevels(uselevel);
0102     
0103     <span class="comment">% get the union of inverted signals and check marks in the CPS table</span>
0104     [isin,levels] = ismember(invlevels,tablelevels);
0105     levels = tablelevels(levels(isin));
0106     
0107     <span class="comment">% at least the first one should be there and the inversion type should</span>
0108     <span class="comment">% be okay</span>
0109     <span class="keyword">if</span> any(levels==1) &amp;&amp; InvtypeIsOK &amp;&amp; GatetypeIsOK
0110         <span class="comment">% the pressure / saturation data</span>
0111         table = data.pressure.table;
0112         p0 = cell2mat(table(:,2));
0113         S0 = cell2mat(table(:,3));
0114         SatImbDrain = cell2mat(table(:,4))';
0115         <span class="comment">% used for inversion</span>
0116         p = p0(levels);
0117         S = S0(levels);
0118         SatImbDrain = SatImbDrain(levels);
0119         
0120         <span class="comment">% the NMR signals used for inversion</span>
0121         <span class="keyword">for</span> i = 1:numel(levels)
0122             idata.nmr{levels(i)}.name = data.import.NMR.filesShort{levels(i)};
0123             idata.nmr{levels(i)}.t0 = INVdata{levels(i)}.results.nmrproc.t;
0124             idata.nmr{levels(i)}.g0 = S(i).*<span class="keyword">...</span>
0125                 (INVdata{levels(i)}.results.nmrproc.s./E0(levels(i)));
0126             idata.nmr{levels(i)}.t = INVdata{levels(i)}.results.nmrproc.t;
0127             idata.nmr{levels(i)}.g = S(i).*<span class="keyword">...</span>
0128                 (INVdata{levels(i)}.results.nmrproc.s./E0(levels(i)));
0129             idata.nmr{levels(i)}.e = INVdata{levels(i)}.results.nmrproc.noise./<span class="keyword">...</span>
0130                 sqrt(INVdata{levels(i)}.results.nmrproc.N);
0131             idata.nmr{levels(i)}.N = INVdata{levels(i)}.results.nmrproc.N;
0132             idata.nmr{levels(i)}.noise = S(i).*<span class="keyword">...</span>
0133                 (INVdata{levels(i)}.results.nmrproc.noise./E0(levels(i)));
0134             
0135             <span class="comment">% switch depending on inversion method</span>
0136             <span class="keyword">switch</span> data.invjoint.invtype
0137                 <span class="keyword">case</span> <span class="string">'free'</span>
0138                     <span class="comment">% T1 or T2 data?</span>
0139                     <span class="keyword">if</span> levels(i) == 1
0140                         T1T2flag = INVdata{levels(i)}.results.nmrproc.T1T2;
0141                         T1IRfac = INVdata{levels(i)}.results.nmrproc.T1IRfac;
0142                     <span class="keyword">end</span>
0143                 <span class="keyword">case</span> {<span class="string">'fixed'</span>,<span class="string">'shape'</span>}
0144                     <span class="keyword">if</span> levels(i) == 1
0145                         <span class="comment">% full saturation RTD</span>
0146                         fullsat.T = INVdata{levels(i)}.results.invstd.T1T2me;
0147                         fullsat.F = S(i).*<span class="keyword">...</span>
0148                             (INVdata{levels(i)}.results.invstd.T1T2f./<span class="keyword">...</span>
0149                             sum(INVdata{levels(i)}.results.invstd.T1T2f));
0150                         <span class="comment">% T1 or T2 data?</span>
0151                         T1T2flag = INVdata{levels(i)}.results.nmrproc.T1T2;
0152                         T1IRfac = INVdata{levels(i)}.results.nmrproc.T1IRfac;
0153                     <span class="keyword">end</span>
0154             <span class="keyword">end</span>
0155         <span class="keyword">end</span>
0156         
0157         <span class="comment">% stack all NMR signals into one long vector</span>
0158         c = 0;
0159         indt = zeros(size(levels));
0160         <span class="keyword">for</span> i = 1:numel(levels)
0161             c = c + 1;
0162             <span class="keyword">if</span> c == 1
0163                 t = idata.nmr{levels(i)}.t';
0164                 g = idata.nmr{levels(i)}.g';
0165                 e = idata.nmr{levels(i)}.e';
0166                 N = idata.nmr{levels(i)}.N';
0167             <span class="keyword">else</span>
0168                 t = [t idata.nmr{levels(i)}.t'];
0169                 g = [g idata.nmr{levels(i)}.g'];
0170                 e = [e idata.nmr{levels(i)}.e'];
0171                 N = [N idata.nmr{levels(i)}.N'];
0172             <span class="keyword">end</span>
0173             indt(c) = length(idata.nmr{levels(i)}.t);
0174         <span class="keyword">end</span>
0175         
0176         <span class="comment">% create the error weighing matrix</span>
0177         <span class="keyword">if</span> strcmp(unique(gatetype),<span class="string">'log'</span>) || strcmp(unique(gatetype),<span class="string">'lin'</span>)
0178             W = diag(e);
0179             useW = true;
0180         <span class="keyword">else</span>
0181             useW = false;
0182         <span class="keyword">end</span>
0183         
0184         <span class="comment">% inversion output on the command line</span>
0185         <span class="keyword">switch</span> data.info.InvInfo
0186             <span class="keyword">case</span> <span class="string">'on'</span>
0187                 info = <span class="string">'iter'</span>;
0188             <span class="keyword">case</span> <span class="string">'off'</span>
0189                 info = <span class="string">'off'</span>;
0190         <span class="keyword">end</span>
0191         
0192         <span class="comment">% switch depending on inversion method</span>
0193         <span class="keyword">switch</span> data.invjoint.invtype            
0194             <span class="keyword">case</span> <span class="string">'free'</span>
0195                 <span class="comment">% radii distribution</span>
0196                 r_start = log10(data.invjoint.radii(1));
0197                 r_end = log10(data.invjoint.radii(2));
0198                 r = logspace(r_start,r_end,(r_end-r_start)*data.invjoint.Nradii);
0199                 
0200                 <span class="comment">% inversion geometry</span>
0201                 igeom.type = data.invjoint.geometry_type;
0202                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0203                 igeom.polyN = data.invjoint.polyN;
0204                 igeom.radius = r';
0205                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0206                 
0207                 <span class="comment">% saturation for the inversion model</span>
0208                 ipsddata.r = igeom.radius';
0209                 ipsddata.psd = ones(size(ipsddata.r));
0210                 <span class="comment">% wait-bar option</span>
0211                 wbopts.show = false;
0212                 wbopts.tag = <span class="string">'INV'</span>;
0213                 iSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(igeom,p,ipsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0214                 IPS = <a href="../../../nucleus/functions/modeling/getPartialSaturationMatrix.html" class="code" title="function IPS = getPartialSaturationMatrix(SatData,indt,imbdrain)">getPartialSaturationMatrix</a>(iSAT,indt,SatImbDrain);
0215                 <span class="comment">% get the amplitudes and surface to volume ratios for all shapes</span>
0216                 SVdata = <a href="../../../nucleus/functions/modeling/getCornerNMRparameter.html" class="code" title="function out = getCornerNMRparameter(geometry,SatData,indt,imbdrain)">getCornerNMRparameter</a>(igeom,iSAT,indt,SatImbDrain);
0217                 SVdata.TT = repmat(t',[1 length(SVdata.SVF)]);
0218                 
0219                 <span class="comment">% derivative matrix</span>
0220                 L = get_l(length(ipsddata.r),data.invjoint.Lorder);
0221                 
0222                 <span class="comment">% switch depending on regularization method</span>
0223                 <span class="keyword">switch</span> data.invjoint.regtype                    
0224                     <span class="keyword">case</span> <span class="string">'lcurve'</span>
0225                         <span class="comment">% clear axes</span>
0226                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.all);
0227                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.rtd);
0228                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.psd);
0229                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.psdj);
0230                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.cps);
0231                         
0232                         <span class="comment">% make the RUN button a STOP button</span>
0233                         <span class="comment">% set &quot;UserData&quot; to 1 to catch a STOP button event</span>
0234                         set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'STOP'</span>,<span class="keyword">...</span>
0235                             <span class="string">'BackGroundColor'</span>,<span class="string">'r'</span>,<span class="string">'UserData'</span>,1,<span class="string">'Callback'</span>,@<a href="../../../nucleus/callbacks/push/onPushStop.html" class="code" title="function onPushStop(src,~)">onPushStop</a>);
0236                         
0237                         <span class="comment">% no command line output during l-curve calculation</span>
0238                         info = <span class="string">'off'</span>;
0239                         
0240                         <span class="comment">% lambda range and initialization of output variables</span>
0241                         lambda_range = logspace(log10(data.invjoint.lambdaR(1)),<span class="keyword">...</span>
0242                             log10(data.invjoint.lambdaR(2)),data.invjoint.NlambdaR);
0243                         RMS = zeros(size(lambda_range));
0244                         XN = zeros(size(lambda_range));
0245                         RN = zeros(size(lambda_range));
0246                         
0247                         <span class="comment">% status bar information</span>
0248                         infostring = <span class="string">'L-Curve calculation ... '</span>;
0249                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0250                         
0251                         <span class="comment">% wait-bar option</span>
0252                         wbopts.show = true;
0253                         wbopts.tag = <span class="string">'INV'</span>;
0254                         <span class="keyword">if</span> wbopts.show
0255                             hwb = waitbar(0,<span class="string">'processing ...'</span>,<span class="string">'Name'</span>,<span class="string">'L-Curve calculation'</span>,<span class="string">'Visible'</span>,<span class="string">'off'</span>);
0256                             steps = length(lambda_range);
0257                             fig = findobj(<span class="string">'Tag'</span>,wbopts.tag);
0258                             <span class="keyword">if</span> ~isempty(fig)
0259                                 posf = get(fig,<span class="string">'Position'</span>);
0260                                 set(hwb,<span class="string">'Units'</span>,<span class="string">'Pixel'</span>)
0261                                 posw = get(hwb,<span class="string">'Position'</span>);
0262                                 set(hwb,<span class="string">'Position'</span>,[posf(1)+posf(3)/2-posw(3)/2 posf(2)+posf(4)/2-posw(4)/2 posw(3:4)]);
0263                             <span class="keyword">end</span>
0264                             set(hwb,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
0265                         <span class="keyword">end</span>
0266                         
0267                         <span class="comment">% the L-curve calculation</span>
0268                         <span class="keyword">for</span> i = 1:length(lambda_range)
0269                             <span class="comment">% check if the STOP button was pressed</span>
0270                             <span class="comment">% if &quot;UserData&quot; is 1 STOP was not pressed -&gt; continue</span>
0271                             <span class="keyword">if</span> get(gui.push_handles.invjoint_run,<span class="string">'UserData'</span>) == 1
0272                                 
0273                                 iparam.t = t;
0274                                 iparam.g = g;
0275                                 <span class="keyword">if</span> useW
0276                                     iparam.W = W;
0277                                 <span class="keyword">end</span>
0278                                 iparam.Tb = data.invstd.Tbulk;
0279                                 iparam.T1T2 = T1T2flag;
0280                                 iparam.T1IRfac = T1IRfac;
0281                                 iparam.L = L;
0282                                 iparam.lambda = lambda_range(i);
0283                                 iparam.igeom = igeom;
0284                                 iparam.IPS = IPS;
0285                                 iparam.SVdata = SVdata;
0286                                 iparam.SatImbDrain = SatImbDrain;
0287                                 
0288                                 <span class="comment">% start values and bounds</span>
0289                                 x0 = [zeros(size(igeom.radius))' log10(1e-6)];
0290                                 lb = [zeros(size(igeom.radius))' log10(1e-8)];
0291                                 ub = [ones(size(igeom.radius))' log10(1e-3)];
0292                                 
0293                                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-9,<span class="string">'TolX'</span>,1e-9,<span class="keyword">...</span>
0294                                     <span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'FinDiffType'</span>,<span class="string">'central'</span>,<span class="keyword">...</span>
0295                                     <span class="string">'Algorithm'</span>,<span class="string">'levenberg-marquardt'</span>,<span class="string">'MaxIter'</span>,1000);
0296                                 
0297                                 [X,~,~,~] = lsqnonlin(@(X)<a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam),x0,lb,ub,options);
0298                                 [~,~,ig,~] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam);
0299                                 
0300                                 <span class="keyword">if</span> useW
0301                                     <span class="comment">% normalize the fit because the signal was error</span>
0302                                     <span class="comment">% weighted for the inversion</span>
0303                                     e = diag(iparam.W);
0304                                     einv = 1./e;
0305                                     Winv = diag(einv);
0306                                     ig = Winv * ig;
0307                                 <span class="keyword">end</span>
0308                         
0309                                 residual = ig - g';
0310                                 iF = X(1:length(X)-1);
0311                                 
0312                                 <span class="comment">% output data</span>
0313                                 <span class="comment">% get RMS and X^2</span>
0314                                 <span class="keyword">if</span> useW
0315                                     <span class="comment">% weighted RMS error</span>
0316                                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0317                                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0318                                     RMS(i) = sqrt (sum(N'.*(residual).^2) / length(residual));
0319                                     <span class="comment">% X2 estimate</span>
0320                                     CHI2(i) = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0321                                 <span class="keyword">else</span>
0322                                     <span class="comment">% RMS error</span>
0323                                     RMS(i) = sqrt( sum(residual.^2) / length(residual) );
0324                                     <span class="comment">% X2 estimate</span>
0325                                     CHI2(i) = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0326                                 <span class="keyword">end</span>
0327                                 <span class="comment">% error norm and model norm</span>
0328                                 RN(i) = norm(residual,2);
0329                                 XN(i) = norm(L*iF',2);
0330                                 <span class="comment">% wait-bar update</span>
0331                                 <span class="keyword">if</span> wbopts.show
0332                                     waitbar(i / steps,hwb,[<span class="string">'processing ...'</span>,num2str(i),<span class="string">' / '</span>,num2str(steps),<span class="string">' lambda steps'</span>]);
0333                                 <span class="keyword">end</span>
0334                             <span class="keyword">end</span>
0335                         <span class="keyword">end</span>                        
0336                         <span class="comment">% delete the wait-bar</span>
0337                         <span class="keyword">if</span> wbopts.show
0338                             delete(hwb);
0339                         <span class="keyword">end</span>
0340                         
0341                         <span class="comment">% check if the STOP button was pressed</span>
0342                         <span class="comment">% if &quot;UserData&quot; is 1 STOP was not pressed -&gt; save data</span>
0343                         <span class="keyword">if</span> get(gui.push_handles.invjoint_run,<span class="string">'UserData'</span>) == 1
0344                             lc.lambda = lambda_range;
0345                             lc.RMS = RMS;
0346                             lc.RN = RN;
0347                             lc.XN = XN;
0348                             <span class="comment">% get optimal lambda</span>
0349 <span class="comment">%                             lc.index = getLambdaFromRMS(lc.lambda,lc.RMS,0);</span>
0350                             lc.index = <a href="../../../nucleus/functions/inversion/getLambdaFromLCurve.html" class="code" title="function index = getLambdaFromLCurve(rho,eta,plotit)">getLambdaFromLCurve</a>(RN,XN,0);
0351                             data.results.lcurve = lc;
0352                             <span class="comment">% update GUI data</span>
0353                             setappdata(fig,<span class="string">'data'</span>,data);
0354                             <span class="comment">% update L-curve plots</span>
0355                             <a href="updatePlotsLcurve.html" class="code" title="function updatePlotsLcurve">updatePlotsLcurve</a>;
0356                             <span class="comment">% status bar information</span>
0357                             <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">' done'</span>]);
0358                             <span class="comment">% set focus on results</span>
0359                             set(gui.plots.DistPanel,<span class="string">'Selection'</span>,1);
0360                         <span class="keyword">else</span>
0361                             <span class="comment">% status bar information</span>
0362                             <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">' was canceled'</span>]);
0363                             <span class="comment">% remove temporary data fields</span>
0364                             data = <a href="removeInversionFields.html" class="code" title="function data = removeInversionFields(data)">removeInversionFields</a>(data);
0365                         <span class="keyword">end</span>
0366                         
0367                     <span class="keyword">case</span> <span class="string">'manual'</span>
0368                         <span class="comment">% disable the RUN button to indicate a running inversion</span>
0369                         set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0370                             <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);  
0371             
0372                         <span class="comment">% inversion parameter</span>
0373                         iparam.t = t;
0374                         iparam.g = g;
0375                         <span class="keyword">if</span> useW
0376                             iparam.W = W;
0377                         <span class="keyword">end</span>
0378                         iparam.Tb = data.invstd.Tbulk;
0379                         iparam.T1T2 = T1T2flag;
0380                         iparam.T1IRfac = T1IRfac;
0381                         iparam.L = L;
0382                         iparam.lambda = data.invjoint.lambda;
0383                         iparam.igeom = igeom;
0384                         iparam.IPS = IPS;
0385                         iparam.SVdata = SVdata;
0386                         iparam.SatImbDrain = SatImbDrain;
0387                         
0388                         <span class="comment">% start values and bounds</span>
0389                         x0 = [zeros(size(igeom.radius))' log10(1e-6)];
0390                         lb = [zeros(size(igeom.radius))' log10(1e-8)];
0391                         ub = [ones(size(igeom.radius))' log10(1e-3)];
0392                         
0393                         <span class="comment">% status bar information</span>
0394                         infostring = <span class="string">'Joint Inversion (free) using ''lsqnonlin'' ... '</span>;
0395                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0396                         
0397                         <span class="comment">% optimization settings</span>
0398                         <span class="keyword">if</span> strcmp(T1T2flag,<span class="string">'T1'</span>) &amp;&amp; <span class="keyword">...</span>
0399                                 strcmp(data.invjoint.geometry_type,<span class="string">'ang'</span>)
0400                             options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0401                                 <span class="string">'Jacobian'</span>,<span class="string">'off'</span>,<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'FinDiffType'</span>,<span class="string">'central'</span>,<span class="keyword">...</span>
0402                                 <span class="string">'Algorithm'</span>,<span class="string">'levenberg-marquardt'</span>,<span class="keyword">...</span>
0403                                 <span class="string">'MaxIter'</span>,1000);
0404                         <span class="keyword">else</span>
0405                             options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0406                                 <span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'FinDiffType'</span>,<span class="string">'central'</span>,<span class="keyword">...</span>
0407                                 <span class="string">'Algorithm'</span>,<span class="string">'levenberg-marquardt'</span>,<span class="keyword">...</span>
0408                                 <span class="string">'MaxIter'</span>,1000);
0409                         <span class="keyword">end</span>
0410                         [X,~,~,exitflag] = lsqnonlin(@(X)<a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam),x0,lb,ub,options);
0411                         <span class="comment">% status bar information</span>
0412                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0413                         <span class="comment">% get the final fit</span>
0414                         [~,~,ig,KK] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam);
0415                         
0416                         <span class="keyword">if</span> useW
0417                             <span class="comment">% normalize the fit because the signal was error</span>
0418                             <span class="comment">% weighted for the inversion</span>
0419                             e = diag(iparam.W);
0420                             einv = 1./e;
0421                             Winv = diag(einv);
0422                             ig = Winv * ig;
0423                         <span class="keyword">end</span>
0424                 
0425                         <span class="comment">% the inverted surface relaxivity and PSD</span>
0426                         iF = X(1:length(X)-1);
0427                         irho = 10^X(length(X));
0428                         <span class="comment">% inversion output</span>
0429                         data.results.invjoint.p0 = p0;
0430                         data.results.invjoint.S0 = S0;
0431                         data.results.invjoint.levels = levels;
0432                         data.results.invjoint.T1T2 = T1T2flag;
0433                         data.results.invjoint.T1IRfac = T1IRfac;
0434                         data.results.invjoint.x0 = x0;
0435                         data.results.invjoint.lb = lb;
0436                         data.results.invjoint.ub = ub;
0437                         data.results.invjoint.iparam = iparam;
0438                         data.results.invjoint.iGEOM = igeom;
0439                         data.results.invjoint.iSAT = iSAT;
0440                         data.results.invjoint.iF = iF';
0441                         data.results.invjoint.irho = irho;
0442                         data.results.invjoint.ig = ig;
0443                         data.results.invjoint.XX = KK;
0444                         data.results.invjoint.errnorm = norm((ig - g')).^2;
0445                         data.results.invjoint.residual = ig - g';
0446                         data.results.invjoint.exitflag = exitflag;
0447                         
0448                         <span class="comment">% get RMS and X^2</span>
0449                         residual = data.results.invjoint.residual;
0450                         <span class="keyword">if</span> useW
0451                             <span class="comment">% weighted RMS error</span>
0452                             <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0453                             <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0454                             data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0455                             <span class="comment">% X2 estimate</span>
0456                             data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0457                         <span class="keyword">else</span>
0458                             <span class="comment">% RMS error</span>
0459                             data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0460                             <span class="comment">% X2 estimate</span>
0461                             data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0462                         <span class="keyword">end</span>
0463                                                 
0464                         <span class="comment">% predict CPS curves for the final model</span>
0465                         infostring = <span class="string">'calculate CPS curve ... '</span>;
0466                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0467                         ppsddata.r = igeom.radius';
0468                         ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0469                         <span class="keyword">if</span> min(p) == 0
0470                             p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0471                         <span class="keyword">else</span>
0472                             p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0473                         <span class="keyword">end</span>
0474                         pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(igeom,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0475                         <span class="comment">% save</span>
0476                         data.results.invjoint.pSAT = pSAT;
0477                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]); 
0478                 <span class="keyword">end</span>
0479                 
0480             <span class="keyword">case</span> <span class="string">'fixed'</span> <span class="comment">% only invert for rho</span>
0481                 <span class="comment">% disable the RUN button to indicate a running inversion</span>
0482                 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0483                     <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0484                 
0485                 <span class="comment">% inversion geometry</span>
0486                 igeom.type = data.invjoint.geometry_type;
0487                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0488                 igeom.polyN = data.invjoint.polyN;
0489                 igeom.radius = data.param.rho.*data.param.a.*fullsat.T; <span class="comment">% first guess</span>
0490                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0491                 
0492                 iparam.t = t;
0493                 iparam.g = g;
0494                 <span class="keyword">if</span> useW
0495                     iparam.W = W;
0496                 <span class="keyword">end</span>
0497                 iparam.indt = indt;
0498                 iparam.Tb = data.invstd.Tbulk;
0499                 iparam.T1T2 = T1T2flag;
0500                 iparam.T1IRfac = T1IRfac;
0501                 iparam.SatImbDrain = SatImbDrain;
0502                 iparam.p = p;
0503                 iparam.igeom = igeom;
0504                 iparam.x = fullsat.T';
0505                 iparam.f = fullsat.F';
0506                 
0507                 <span class="comment">% start values</span>
0508                 x0 = log10(data.invjoint.rhostart/1e6);
0509                 lb = log10(1e-8);
0510                 ub = log10(1e-3);
0511                 
0512                 infostring = <span class="string">'Joint Inversion (fixed) using ''fminsearchbnd'' ... '</span>;
0513                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0514                 
0515                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0516                     <span class="string">'MaxFunEvals'</span>,300,<span class="string">'MaxIter'</span>,300);
0517                 X = fminsearchbnd(@(X) <a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>(X,iparam),x0,lb,ub,options);
0518                 
0519                 [errnorm,ig,XX,iGEOM,iSAT] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>(X,iparam);
0520                 
0521                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0522                 
0523                 <span class="keyword">if</span> useW
0524                     <span class="comment">% normalize the fit because the signal was error</span>
0525                     <span class="comment">% weighted for the inversion</span>
0526                     e = diag(iparam.W);
0527                     einv = 1./e;
0528                     Winv = diag(einv);
0529                     ig = Winv * ig;
0530                 <span class="keyword">end</span>                
0531                 
0532                 <span class="comment">% inverted surface relaxivity</span>
0533                 irho = 10^X(1);
0534                 <span class="comment">% output data</span>
0535                 data.results.invjoint.p0 = p0;
0536                 data.results.invjoint.S0 = S0;
0537                 data.results.invjoint.levels = levels;
0538                 data.results.invjoint.T1T2 = T1T2flag;
0539                 data.results.invjoint.T1IRfac = T1IRfac;
0540                 data.results.invjoint.x0 = x0;
0541                 data.results.invjoint.lb = lb;
0542                 data.results.invjoint.ub = ub;
0543                 data.results.invjoint.iparam = iparam;
0544                 data.results.invjoint.iGEOM = iGEOM;
0545                 data.results.invjoint.iSAT = iSAT;
0546                 data.results.invjoint.iF = fullsat.F;
0547                 data.results.invjoint.irho = irho;
0548                 data.results.invjoint.ig = ig;
0549                 data.results.invjoint.XX = XX;
0550                 data.results.invjoint.errnorm = errnorm;
0551                 data.results.invjoint.residual = ig-g';
0552                 
0553                 <span class="comment">% get RMS and X^2</span>
0554                 residual = data.results.invjoint.residual;
0555                 <span class="keyword">if</span> useW
0556                     <span class="comment">% weighted RMS error</span>
0557                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0558                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0559                     data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0560                     <span class="comment">% X2 estimate</span>
0561                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0562                 <span class="keyword">else</span>
0563                     <span class="comment">% RMS error</span>
0564                     data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0565                     <span class="comment">% X2 estimate</span>
0566                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0567                 <span class="keyword">end</span>
0568                 
0569                 <span class="comment">% predict CPS curves from final model</span>
0570                 infostring = <span class="string">'calculate CPS curve ... '</span>;
0571                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0572                 ppsddata.r = iGEOM.radius';
0573                 ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0574                 <span class="keyword">if</span> min(p) == 0
0575                     p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0576                 <span class="keyword">else</span>
0577                     p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0578                 <span class="keyword">end</span>
0579                 <span class="comment">% waitbar option</span>
0580                 wbopts.show = true;
0581                 wbopts.tag = <span class="string">'INV'</span>;
0582                 pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(iGEOM,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0583                 
0584                 data.results.invjoint.pSAT = pSAT;
0585                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0586                 
0587             <span class="keyword">case</span> <span class="string">'shape'</span> <span class="comment">% invert for rho and rectangular shape</span>
0588                 <span class="comment">% disable the RUN button to indicate a running inversion</span>
0589                 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0590                     <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0591                 
0592                 <span class="comment">% inversion geometry</span>
0593                 igeom.type = data.invjoint.geometry_type;
0594                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0595                 igeom.polyN = data.invjoint.polyN;
0596                 igeom.radius = data.param.rho.*data.param.a.*fullsat.T; <span class="comment">% first guess</span>
0597                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0598                 
0599                 iparam.t = t;
0600                 iparam.g = g;
0601                 <span class="keyword">if</span> useW
0602                     iparam.W = W;
0603                 <span class="keyword">end</span>
0604                 iparam.indt = indt;
0605                 iparam.Tb = data.invstd.Tbulk;
0606                 iparam.T1T2 = T1T2flag;
0607                 iparam.T1IRfac = T1IRfac;
0608                 iparam.SatImbDrain = SatImbDrain;
0609                 iparam.p = p;
0610                 iparam.igeom = igeom;
0611                 iparam.x = fullsat.T';
0612                 iparam.f = fullsat.F';
0613                 
0614                 <span class="comment">% scale fit parameter between [0 1]</span>
0615                 <span class="comment">% x0 = [(log10(1e-6)+7)/3 data.invjoint.beta/45];</span>
0616                 <span class="comment">% lb = [(log10(1e-7)+7)/3 0.1/45];</span>
0617                 <span class="comment">% ub = [(log10(1e-4)+7)/3 45/45];</span>
0618                 <span class="comment">% old way</span>
0619                 x0 = [log10(data.invjoint.rhostart/1e6) data.invjoint.anglestart];
0620                 lb = [log10(1e-8) 0.1];
0621                 ub = [log10(1e-3) 45];
0622                 
0623                 infostring = <span class="string">'Joint Inversion (shape) using ''fminsearchbnd'' ... '</span>;
0624                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0625                 options = optimset(<span class="string">'Display'</span>,<span class="string">'iter'</span>,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="string">'MaxIter'</span>,500);
0626                 options.Algorithm = <span class="string">'levenberg-marquardt'</span>;
0627                 options.MaxFunEvals = 500;
0628                 options.DiffMinChange = 1;
0629                 
0630                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-9,<span class="string">'TolX'</span>,1e-9,<span class="keyword">...</span>
0631                     <span class="string">'MaxFunEvals'</span>,300,<span class="string">'MaxIter'</span>,300);
0632                 X = fminsearchbnd(@(X) <a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>(X,iparam),x0,lb,ub,options);
0633                 
0634                 [errnorm,ig,XX,iGEOM,iSAT] = <a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>(X,iparam);
0635                 
0636                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0637                 
0638                 <span class="keyword">if</span> useW
0639                     <span class="comment">% normalize the fit because the signal was error</span>
0640                     <span class="comment">% weighted for the inversion</span>
0641                     e = diag(iparam.W);
0642                     einv = 1./e;
0643                     Winv = diag(einv);
0644                     ig = Winv * ig;
0645                 <span class="keyword">end</span>
0646                 
0647                 irho = 10^X(1);
0648                 ibeta = X(2);
0649                 
0650                 data.results.invjoint.p0 = p0;
0651                 data.results.invjoint.S0 = S0;
0652                 data.results.invjoint.levels = levels;
0653                 data.results.invjoint.T1T2 = T1T2flag;
0654                 data.results.invjoint.T1IRfac = T1IRfac;
0655                 data.results.invjoint.x0 = x0;
0656                 data.results.invjoint.lb = lb;
0657                 data.results.invjoint.ub = ub;
0658                 data.results.invjoint.iparam = iparam;
0659                 data.results.invjoint.iGEOM = iGEOM;
0660                 data.results.invjoint.iSAT = iSAT;
0661                 data.results.invjoint.iF = fullsat.F;
0662                 data.results.invjoint.irho = irho;
0663                 data.results.invjoint.ibeta = ibeta;
0664                 data.results.invjoint.ig = ig;
0665                 data.results.invjoint.XX = XX;
0666                 data.results.invjoint.errnorm = errnorm;
0667                 data.results.invjoint.residual = ig-g';
0668                 
0669                 <span class="comment">% get RMS and X^2</span>
0670                 residual = data.results.invjoint.residual;
0671                 <span class="keyword">if</span> useW
0672                     <span class="comment">% weighted RMS error</span>
0673                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0674                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0675                     data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0676                     <span class="comment">% X2 estimate</span>
0677                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0678                 <span class="keyword">else</span>
0679                     <span class="comment">% RMS error</span>
0680                     data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0681                     <span class="comment">% X2 estimate</span>
0682                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0683                 <span class="keyword">end</span>
0684                 
0685                 <span class="comment">% predict CPS curves from final model</span>
0686                 infostring = <span class="string">'calculate CPS curve ... '</span>;
0687                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0688                 ppsddata.r = iGEOM.radius';
0689                 ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0690                 <span class="keyword">if</span> min(p) == 0
0691                     p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0692                 <span class="keyword">else</span>
0693                     p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0694                 <span class="keyword">end</span>
0695                 <span class="comment">% wait-bar option</span>
0696                 wbopts.show = true;
0697                 wbopts.tag = <span class="string">'INV'</span>;
0698                 pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(iGEOM,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0699                 
0700                 data.results.invjoint.pSAT = pSAT;
0701                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0702         <span class="keyword">end</span>
0703         
0704         <span class="comment">% if the regularization method was not L-curve then post process the</span>
0705         <span class="comment">% NMR data fits</span>
0706         <span class="keyword">if</span> ~strcmp(data.invjoint.regtype,<span class="string">'lcurve'</span>)
0707             <span class="comment">% get the individual NMR fits</span>
0708             <span class="keyword">for</span> i = 1:1:numel(levels)
0709                 idata.nmr{levels(i)}.fit_t = idata.nmr{levels(i)}.t;
0710                 <span class="keyword">if</span> i == 1
0711                     idata.nmr{levels(i)}.fit_g = ig(1:indt(1));
0712                 <span class="keyword">else</span>
0713                     idata.nmr{levels(i)}.fit_g = ig(sum(indt(1:i-1))+1:sum(indt(1:i-1))+indt(i));
0714                 <span class="keyword">end</span>
0715                 residual = idata.nmr{levels(i)}.fit_g - idata.nmr{levels(i)}.g;
0716                 
0717                 <span class="comment">% get RMS and X^2</span>
0718                 <span class="keyword">if</span> useW
0719                     <span class="comment">% weighted RMS error</span>
0720                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0721                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0722                     N = idata.nmr{levels(i)}.N;
0723                     rms = sqrt (sum(N.*(residual).^2) / length(residual));
0724                     <span class="comment">% X2 estimate</span>
0725                     chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(idata.nmr{levels(i)}.g,<span class="keyword">...</span>
0726                         idata.nmr{levels(i)}.fit_g,<span class="keyword">...</span>
0727                         idata.nmr{levels(i)}.e);
0728                 <span class="keyword">else</span>
0729                     <span class="comment">% RMS error</span>
0730                     rms = sqrt( sum(residual.^2) / length(residual) );
0731                     <span class="comment">% X2 estimate</span>
0732                     chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(idata.nmr{levels(i)}.g,<span class="keyword">...</span>
0733                         idata.nmr{levels(i)}.fit_g,<span class="keyword">...</span>
0734                         idata.nmr{levels(i)}.noise);
0735                 <span class="keyword">end</span>
0736 
0737                 idata.nmr{levels(i)}.residual = residual;
0738                 idata.nmr{levels(i)}.rms = rms;
0739                 idata.nmr{levels(i)}.chi2 = chi2;
0740             <span class="keyword">end</span>
0741             <span class="comment">% save the GUI data</span>
0742             data.results.invjoint.idata = idata;
0743             setappdata(fig,<span class="string">'data'</span>,data);
0744             
0745             <span class="comment">% save the &quot;INVdata&quot;</span>
0746             <span class="keyword">for</span> i = 1:1:numel(levels)
0747                 INVdata{levels(i)}.invjoint = data.invjoint;
0748                 INVdata{levels(i)}.pressure = data.pressure;
0749                 INVdata{levels(i)}.results.invjoint = data.results.invjoint;
0750             <span class="keyword">end</span>
0751             setappdata(fig,<span class="string">'INVdata'</span>,INVdata);
0752             <span class="comment">% update the plots</span>
0753             <a href="updatePlotsJointInversion.html" class="code" title="function updatePlotsJointInversion">updatePlotsJointInversion</a>;
0754             <span class="comment">% update the INFO fields</span>
0755             <a href="updateInfo.html" class="code" title="function updateInfo(src,~) %#ok<INUSD>">updateInfo</a>(gui.plots.SignalPanel);            
0756             <span class="comment">% set focus on results</span>
0757             set(gui.plots.SignalPanel,<span class="string">'Selection'</span>,3);
0758             set(gui.plots.DistPanel,<span class="string">'Selection'</span>,3);
0759             <span class="comment">% open INFO field</span>
0760             set(gui.push_handles.info,<span class="string">'String'</span>,<span class="string">'&lt;'</span>);
0761             <a href="../../../nucleus/callbacks/push/onPushShowHide.html" class="code" title="function onPushShowHide(src,~)">onPushShowHide</a>(gui.push_handles.info);
0762         <span class="keyword">end</span>     
0763     <span class="keyword">else</span>        
0764         <span class="keyword">if</span> ~InvtypeIsOK
0765             helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Perform standard multi-exponential inversion first.'</span>,<span class="keyword">...</span>
0766             <span class="string">'For ''fixed'' and ''shape'' you need a RTD!'</span>},<span class="string">'No RTD'</span>);
0767         <span class="keyword">end</span>
0768         <span class="keyword">if</span> ~GatetypeIsOK
0769             helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Check your ''signal gating'' settings.'</span>,<span class="keyword">...</span>
0770             <span class="string">'All signals need to have the same gating.'</span>},<span class="string">'Wrong gating'</span>);
0771         <span class="keyword">end</span>
0772     <span class="keyword">end</span>
0773 <span class="keyword">else</span>
0774     helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Perform standard inversion first.'</span>,<span class="keyword">...</span>
0775         <span class="string">'For ''fixed'' and ''shape'' you need a RTD!'</span>},<span class="string">'No Data'</span>);
0776 <span class="keyword">end</span>
0777 
0778 <span class="comment">%% at the end, no matter what reset the RUN button</span>
0779 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'&lt;HTML&gt;&lt;u&gt;R&lt;/u&gt;UN'</span>,<span class="keyword">...</span>
0780     <span class="string">'BackgroundColor'</span>,<span class="string">'g'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,<span class="string">'Callback'</span>,@<a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>);
0781 setappdata(fig,<span class="string">'gui'</span>,gui);
0782 
0783 <span class="keyword">end</span>
0784 
0785 <span class="comment">%------------- END OF CODE --------------</span>
0786 
0787 <span class="comment">%% License:</span>
0788 <span class="comment">% MIT License</span>
0789 <span class="comment">%</span>
0790 <span class="comment">% Copyright (c) 2018 Thomas Hiller</span>
0791 <span class="comment">%</span>
0792 <span class="comment">% Permission is hereby granted, free of charge, to any person obtaining a copy</span>
0793 <span class="comment">% of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
0794 <span class="comment">% in the Software without restriction, including without limitation the rights</span>
0795 <span class="comment">% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
0796 <span class="comment">% copies of the Software, and to permit persons to whom the Software is</span>
0797 <span class="comment">% furnished to do so, subject to the following conditions:</span>
0798 <span class="comment">%</span>
0799 <span class="comment">% The above copyright notice and this permission notice shall be included in all</span>
0800 <span class="comment">% copies or substantial portions of the Software.</span>
0801 <span class="comment">%</span>
0802 <span class="comment">% THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
0803 <span class="comment">% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
0804 <span class="comment">% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
0805 <span class="comment">% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
0806 <span class="comment">% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
0807 <span class="comment">% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
0808 <span class="comment">% SOFTWARE.</span></pre></div>
<hr><address>Generated by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>