<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of runInversionJoint</title>
  <meta name="keywords" content="runInversionJoint">
  <meta name="description" content=" controls the joint inversion process to infer a pore size">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # nucleus --><!-- # functions --><!-- menu.html interface -->
<h1>runInversionJoint
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong> controls the joint inversion process to infer a pore size</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function runInversionJoint </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">runInversionJoint controls the joint inversion process to infer a pore size
distribution (PSD) from NMR and CPS data

 Syntax:
       runInversionJoint

 Inputs:
       none

 Outputs:
       none

 Example:
       runInversionJoint

 Other m-files required:
       checkIfInversionExists
       clearSingleAxis
       displayStatusText
       fcn_JointInvfixed
       fcn_JointInvfree
       fcn_JointInvshape
       getChi2
       getLambdaFromRMS
       getConstants
       getCornerNMRparameter
       getGeometryParameter
       getPartialSaturationMatrix    
       getSaturationFromPressureBatch
       onPushRun
       onPushShowHide
       onPushStop
       removeInversionFields    
       updateInfo
       updatePlotsJointInversion    
       updatePlotsLcurve</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>	 handles the callbacks to all RUN push buttons in both GUIs and</li><li><a href="../../../nucleus/callbacks/push/onPushShowHide.html" class="code" title="function onPushShowHide(src,~)">onPushShowHide</a>	 shows/hides the INFO column on the right side of NUCLEUSinv</li><li><a href="../../../nucleus/callbacks/push/onPushStop.html" class="code" title="function onPushStop(src,~)">onPushStop</a>	 recognizes that a STOP push button was pressed and resets the</li><li><a href="checkIfInversionExists.html" class="code" title="function [foundINV,N] = checkIfInversionExists(INVdata)">checkIfInversionExists</a>	 checks if any inversion result is stored inside</li><li><a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>	 clears an individual axis</li><li><a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>	 clears all axes of a given figure</li><li><a href="removeInversionFields.html" class="code" title="function data = removeInversionFields(data)">removeInversionFields</a>	 deletes all inversion result fields from NUCLEUSinv</li><li><a href="updateInfo.html" class="code" title="function updateInfo(src,~) %#ok<INUSD>">updateInfo</a>	 updates the information shown in all information list boxes</li><li><a href="updatePlotsJointInversion.html" class="code" title="function updatePlotsJointInversion">updatePlotsJointInversion</a>	 plots the joint-inversion results in NUCLEUSinv</li><li><a href="updatePlotsLcurve.html" class="code" title="function updatePlotsLcurve">updatePlotsLcurve</a>	</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>	 performs the "fixed" joint inversion using the RTD of</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>	 jointly estimates the pore size distribution and surface</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>	 performs the "shape" joint inversion using the RTD of</li><li><a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>	 the chi2 of a NMR fit (noise weighted error quality)</li><li><a href="../../../nucleus/functions/inversion/getLambdaFromLCurve.html" class="code" title="function index = getLambdaFromLCurve(rho,eta,plotit)">getLambdaFromLCurve</a>	 estimates the regularization parameter lambda according</li><li><a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>	 provides some physical constants to the forward calculation</li><li><a href="../../../nucleus/functions/modeling/getCornerNMRparameter.html" class="code" title="function out = getCornerNMRparameter(geometry,SatData,indt,imbdrain)">getCornerNMRparameter</a>	 calculates corner parameters (amplitude surface to</li><li><a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>	 calculates geometric parameters for the three possible</li><li><a href="../../../nucleus/functions/modeling/getPartialSaturationMatrix.html" class="code" title="function IPS = getPartialSaturationMatrix(SatData,indt,imbdrain)">getPartialSaturationMatrix</a>	 calculates the partial saturation matrix to be</li><li><a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>	 handles the callbacks to all RUN push buttons in both GUIs and</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function runInversionJoint</a>
0002 <span class="comment">%runInversionJoint controls the joint inversion process to infer a pore size</span>
0003 <span class="comment">%distribution (PSD) from NMR and CPS data</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Syntax:</span>
0006 <span class="comment">%       runInversionJoint</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Inputs:</span>
0009 <span class="comment">%       none</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Outputs:</span>
0012 <span class="comment">%       none</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% Example:</span>
0015 <span class="comment">%       runInversionJoint</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Other m-files required:</span>
0018 <span class="comment">%       checkIfInversionExists</span>
0019 <span class="comment">%       clearSingleAxis</span>
0020 <span class="comment">%       displayStatusText</span>
0021 <span class="comment">%       fcn_JointInvfixed</span>
0022 <span class="comment">%       fcn_JointInvfree</span>
0023 <span class="comment">%       fcn_JointInvshape</span>
0024 <span class="comment">%       getChi2</span>
0025 <span class="comment">%       getLambdaFromRMS</span>
0026 <span class="comment">%       getConstants</span>
0027 <span class="comment">%       getCornerNMRparameter</span>
0028 <span class="comment">%       getGeometryParameter</span>
0029 <span class="comment">%       getPartialSaturationMatrix</span>
0030 <span class="comment">%       getSaturationFromPressureBatch</span>
0031 <span class="comment">%       onPushRun</span>
0032 <span class="comment">%       onPushShowHide</span>
0033 <span class="comment">%       onPushStop</span>
0034 <span class="comment">%       removeInversionFields</span>
0035 <span class="comment">%       updateInfo</span>
0036 <span class="comment">%       updatePlotsJointInversion</span>
0037 <span class="comment">%       updatePlotsLcurve</span>
0038 
0039 <span class="comment">%</span>
0040 <span class="comment">% Subfunctions:</span>
0041 <span class="comment">%       none</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% MAT-files required:</span>
0044 <span class="comment">%       none</span>
0045 <span class="comment">%</span>
0046 <span class="comment">% See also: NUCLEUSinv</span>
0047 <span class="comment">% Author: Thomas Hiller</span>
0048 <span class="comment">% email: thomas.hiller[at]leibniz-liag.de</span>
0049 <span class="comment">% License: MIT License (at end)</span>
0050 
0051 <span class="comment">%------------- BEGIN CODE --------------</span>
0052 
0053 <span class="comment">%% get GUI handle and data</span>
0054 fig = findobj(<span class="string">'Tag'</span>,<span class="string">'INV'</span>);
0055 gui = getappdata(fig,<span class="string">'gui'</span>);
0056 data = getappdata(fig,<span class="string">'data'</span>);
0057 INVdata = getappdata(fig,<span class="string">'INVdata'</span>);
0058 
0059 <span class="comment">% check if there is any inversion results at all</span>
0060 foundINV = <a href="checkIfInversionExists.html" class="code" title="function [foundINV,N] = checkIfInversionExists(INVdata)">checkIfInversionExists</a>(INVdata);
0061 
0062 <span class="comment">%% if yes continue</span>
0063 <span class="keyword">if</span> foundINV    
0064     <span class="comment">% check which signals have been inverted before</span>
0065     <span class="comment">% (E0 is needed for Sat-normalization)</span>
0066     nINV = size(INVdata,1);
0067     E0 = zeros(nINV,1);
0068     c = 0;
0069     <span class="keyword">for</span> i = 1:nINV
0070         <span class="keyword">if</span> isstruct(INVdata{i})
0071             c = c + 1;
0072             E0(i,1) = sum(INVdata{i}.results.invstd.E0);
0073             invlevels(c) = i; <span class="comment">%#ok&lt;*AGROW&gt;</span>
0074             invtype{c} = INVdata{i}.invstd.invtype;
0075             gatetype{c} = INVdata{i}.results.nmrproc.gatetype;
0076         <span class="keyword">end</span>
0077     <span class="keyword">end</span>    
0078     <span class="comment">% for &quot;fixed&quot; and &quot;shape&quot; inversion a RTD is needed</span>
0079     InvtypeIsOK = false;
0080     <span class="keyword">switch</span> data.invjoint.invtype
0081         <span class="keyword">case</span> {<span class="string">'fixed'</span>,<span class="string">'shape'</span>}
0082             <span class="keyword">switch</span> invtype{1}
0083                 <span class="keyword">case</span> {<span class="string">'ILA'</span>,<span class="string">'NNLS'</span>}
0084                     InvtypeIsOK = true;
0085                 <span class="keyword">otherwise</span>
0086                     <span class="comment">% nothing to do</span>
0087             <span class="keyword">end</span>
0088         <span class="keyword">otherwise</span>
0089             InvtypeIsOK = true;
0090     <span class="keyword">end</span>
0091     <span class="comment">% check if the gatetype is for all signals the same</span>
0092     GatetypeIsOK = false;
0093     <span class="keyword">if</span> numel(unique(gatetype)) == 1
0094         GatetypeIsOK = true;
0095     <span class="keyword">end</span>
0096     
0097     <span class="comment">% the pressure / saturation data</span>
0098     table = data.pressure.table;
0099     uselevel = cell2mat(table(:,1));
0100     tablelevels = 1:size(table,1);
0101     tablelevels = tablelevels(uselevel);
0102     
0103     <span class="comment">% get the union of inverted signals and check marks in the CPS table</span>
0104     [isin,levels] = ismember(invlevels,tablelevels);
0105     levels = tablelevels(levels(isin));
0106     
0107     <span class="comment">% at least the first one should be there and the inversion type should</span>
0108     <span class="comment">% be okay</span>
0109     <span class="keyword">if</span> any(levels==1) &amp;&amp; InvtypeIsOK &amp;&amp; GatetypeIsOK
0110         <span class="comment">% the pressure / saturation data</span>
0111         table = data.pressure.table;
0112         p0 = cell2mat(table(:,2));
0113         S0 = cell2mat(table(:,3));
0114         SatImbDrain = cell2mat(table(:,4))';
0115         <span class="comment">% used for inversion</span>
0116         p = p0(levels);
0117         S = S0(levels);
0118         SatImbDrain = SatImbDrain(levels);
0119         
0120         <span class="comment">% the NMR signals used for inversion</span>
0121         <span class="keyword">for</span> i = 1:numel(levels)
0122             idata.nmr{levels(i)}.name = data.import.NMR.filesShort{levels(i)};
0123             idata.nmr{levels(i)}.t0 = INVdata{levels(i)}.results.nmrproc.t;
0124             idata.nmr{levels(i)}.g0 = S(i).*<span class="keyword">...</span>
0125                 (INVdata{levels(i)}.results.nmrproc.s./E0(levels(i)));
0126             idata.nmr{levels(i)}.t = INVdata{levels(i)}.results.nmrproc.t;
0127             idata.nmr{levels(i)}.g = S(i).*<span class="keyword">...</span>
0128                 (INVdata{levels(i)}.results.nmrproc.s./E0(levels(i)));
0129             idata.nmr{levels(i)}.N = INVdata{levels(i)}.results.nmrproc.N;
0130             idata.nmr{levels(i)}.noise = S(i).*<span class="keyword">...</span>
0131                 (INVdata{levels(i)}.results.nmrproc.noise./E0(levels(i)));
0132             idata.nmr{levels(i)}.e = idata.nmr{levels(i)}.noise./<span class="keyword">...</span>
0133                 sqrt(idata.nmr{levels(i)}.N);
0134             
0135             <span class="comment">% switch depending on inversion method</span>
0136             <span class="keyword">switch</span> data.invjoint.invtype
0137                 <span class="keyword">case</span> <span class="string">'free'</span>
0138                     <span class="comment">% T1 or T2 data?</span>
0139                     <span class="keyword">if</span> levels(i) == 1
0140                         T1T2flag = INVdata{levels(i)}.results.nmrproc.T1T2;
0141                         T1IRfac = INVdata{levels(i)}.results.nmrproc.T1IRfac;
0142                     <span class="keyword">end</span>
0143                 <span class="keyword">case</span> {<span class="string">'fixed'</span>,<span class="string">'shape'</span>}
0144                     <span class="keyword">if</span> levels(i) == 1
0145                         <span class="comment">% full saturation RTD</span>
0146                         fullsat.T = INVdata{levels(i)}.results.invstd.T1T2me;
0147                         fullsat.F = S(i).*<span class="keyword">...</span>
0148                             (INVdata{levels(i)}.results.invstd.T1T2f./<span class="keyword">...</span>
0149                             sum(INVdata{levels(i)}.results.invstd.T1T2f));
0150                         <span class="comment">% T1 or T2 data?</span>
0151                         T1T2flag = INVdata{levels(i)}.results.nmrproc.T1T2;
0152                         T1IRfac = INVdata{levels(i)}.results.nmrproc.T1IRfac;
0153                     <span class="keyword">end</span>
0154             <span class="keyword">end</span>
0155         <span class="keyword">end</span>
0156         
0157         <span class="comment">% stack all NMR signals into one long vector</span>
0158         c = 0;
0159         indt = zeros(size(levels));
0160         <span class="keyword">for</span> i = 1:numel(levels)
0161             c = c + 1;
0162             <span class="keyword">if</span> c == 1
0163                 t = idata.nmr{levels(i)}.t';
0164                 g = idata.nmr{levels(i)}.g';
0165                 e = idata.nmr{levels(i)}.e';
0166                 N = idata.nmr{levels(i)}.N';
0167             <span class="keyword">else</span>
0168                 t = [t idata.nmr{levels(i)}.t'];
0169                 g = [g idata.nmr{levels(i)}.g'];
0170                 e = [e idata.nmr{levels(i)}.e'];
0171                 N = [N idata.nmr{levels(i)}.N'];
0172             <span class="keyword">end</span>
0173             indt(c) = length(idata.nmr{levels(i)}.t);
0174         <span class="keyword">end</span>
0175         
0176         <span class="comment">% create the error weighing matrix</span>
0177         <span class="keyword">if</span> strcmp(unique(gatetype),<span class="string">'log'</span>) || strcmp(unique(gatetype),<span class="string">'lin'</span>)
0178             W = diag(e);
0179             useW = true;
0180         <span class="keyword">else</span>
0181             useW = false;
0182         <span class="keyword">end</span>
0183         
0184         <span class="comment">% inversion output on the command line</span>
0185         <span class="keyword">switch</span> data.info.InvInfo
0186             <span class="keyword">case</span> <span class="string">'on'</span>
0187                 info = <span class="string">'iter'</span>;
0188             <span class="keyword">case</span> <span class="string">'off'</span>
0189                 info = <span class="string">'off'</span>;
0190         <span class="keyword">end</span>
0191         
0192         <span class="comment">% switch depending on inversion method</span>
0193         <span class="keyword">switch</span> data.invjoint.invtype            
0194             <span class="keyword">case</span> <span class="string">'free'</span>
0195                 <span class="comment">% radii distribution</span>
0196                 r_start = log10(data.invjoint.radii(1));
0197                 r_end = log10(data.invjoint.radii(2));
0198                 r = logspace(r_start,r_end,(r_end-r_start)*data.invjoint.Nradii);
0199                 
0200                 <span class="comment">% inversion geometry</span>
0201                 igeom.type = data.invjoint.geometry_type;
0202                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0203                 igeom.polyN = data.invjoint.polyN;
0204                 igeom.radius = r';
0205                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0206                 
0207                 <span class="comment">% saturation for the inversion model</span>
0208                 ipsddata.r = igeom.radius';
0209                 ipsddata.psd = ones(size(ipsddata.r));
0210                 <span class="comment">% wait-bar option</span>
0211                 wbopts.show = false;
0212                 wbopts.tag = <span class="string">'INV'</span>;
0213                 iSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(igeom,p,ipsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0214                 IPS = <a href="../../../nucleus/functions/modeling/getPartialSaturationMatrix.html" class="code" title="function IPS = getPartialSaturationMatrix(SatData,indt,imbdrain)">getPartialSaturationMatrix</a>(iSAT,indt,SatImbDrain);
0215                 <span class="comment">% get the amplitudes and surface to volume ratios for all shapes</span>
0216                 SVdata = <a href="../../../nucleus/functions/modeling/getCornerNMRparameter.html" class="code" title="function out = getCornerNMRparameter(geometry,SatData,indt,imbdrain)">getCornerNMRparameter</a>(igeom,iSAT,indt,SatImbDrain);
0217                 SVdata.TT = repmat(t',[1 length(SVdata.SVF)]);
0218                 
0219                 <span class="comment">% derivative matrix</span>
0220                 L = get_l(length(ipsddata.r),data.invjoint.Lorder);
0221                 
0222                 <span class="comment">% switch depending on regularization method</span>
0223                 <span class="keyword">switch</span> data.invjoint.regtype                    
0224                     <span class="keyword">case</span> <span class="string">'lcurve'</span>
0225                         <span class="comment">% clear axes</span>
0226                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.all);
0227                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.rtd);
0228                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.psd);
0229                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.psdj);
0230                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.cps);
0231                         
0232                         <span class="comment">% make the RUN button a STOP button</span>
0233                         <span class="comment">% set &quot;UserData&quot; to 1 to catch a STOP button event</span>
0234                         set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'STOP'</span>,<span class="keyword">...</span>
0235                             <span class="string">'BackGroundColor'</span>,<span class="string">'r'</span>,<span class="string">'UserData'</span>,1,<span class="string">'Callback'</span>,@<a href="../../../nucleus/callbacks/push/onPushStop.html" class="code" title="function onPushStop(src,~)">onPushStop</a>);
0236                         
0237                         <span class="comment">% no command line output during l-curve calculation</span>
0238                         info = <span class="string">'off'</span>;
0239                         
0240                         <span class="comment">% lambda range and initialization of output variables</span>
0241                         lambda_range = logspace(log10(data.invjoint.lambdaR(1)),<span class="keyword">...</span>
0242                             log10(data.invjoint.lambdaR(2)),data.invjoint.NlambdaR);
0243                         RMS = zeros(size(lambda_range));
0244                         XN = zeros(size(lambda_range));
0245                         RN = zeros(size(lambda_range));
0246                         
0247                         <span class="comment">% status bar information</span>
0248                         infostring = <span class="string">'L-Curve calculation ... '</span>;
0249                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0250                         
0251                         <span class="comment">% wait-bar option</span>
0252                         wbopts.show = true;
0253                         wbopts.tag = <span class="string">'INV'</span>;
0254                         <span class="keyword">if</span> wbopts.show
0255                             hwb = waitbar(0,<span class="string">'processing ...'</span>,<span class="string">'Name'</span>,<span class="string">'L-Curve calculation'</span>,<span class="string">'Visible'</span>,<span class="string">'off'</span>);
0256                             steps = length(lambda_range);
0257                             fig = findobj(<span class="string">'Tag'</span>,wbopts.tag);
0258                             <span class="keyword">if</span> ~isempty(fig)
0259                                 posf = get(fig,<span class="string">'Position'</span>);
0260                                 set(hwb,<span class="string">'Units'</span>,<span class="string">'Pixel'</span>)
0261                                 posw = get(hwb,<span class="string">'Position'</span>);
0262                                 set(hwb,<span class="string">'Position'</span>,[posf(1)+posf(3)/2-posw(3)/2 posf(2)+posf(4)/2-posw(4)/2 posw(3:4)]);
0263                             <span class="keyword">end</span>
0264                             set(hwb,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
0265                         <span class="keyword">end</span>
0266                         
0267                         <span class="comment">% the L-curve calculation</span>
0268                         <span class="keyword">for</span> i = 1:length(lambda_range)
0269                             <span class="comment">% check if the STOP button was pressed</span>
0270                             <span class="comment">% if &quot;UserData&quot; is 1 STOP was not pressed -&gt; continue</span>
0271                             <span class="keyword">if</span> get(gui.push_handles.invjoint_run,<span class="string">'UserData'</span>) == 1
0272                                 
0273                                 iparam.t = t;
0274                                 iparam.g = g;
0275                                 <span class="keyword">if</span> useW
0276                                     iparam.W = W;
0277                                 <span class="keyword">end</span>
0278                                 iparam.Tb = data.invstd.Tbulk;
0279                                 iparam.T1T2 = T1T2flag;
0280                                 iparam.T1IRfac = T1IRfac;
0281                                 iparam.L = L;
0282                                 iparam.lambda = lambda_range(i);
0283                                 iparam.igeom = igeom;
0284                                 iparam.IPS = IPS;
0285                                 iparam.SVdata = SVdata;
0286                                 iparam.SatImbDrain = SatImbDrain;
0287                                 
0288                                 <span class="comment">% start values and bounds</span>
0289                                 x0 = [zeros(size(igeom.radius))' log10(1e-6)];
0290                                 lb = [zeros(size(igeom.radius))' log10(1e-8)];
0291                                 ub = [ones(size(igeom.radius))' log10(1e-3)];
0292                                 
0293                                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0294                                     <span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'FinDiffType'</span>,<span class="string">'central'</span>,<span class="keyword">...</span>
0295                                     <span class="string">'Algorithm'</span>,<span class="string">'levenberg-marquardt'</span>,<span class="keyword">...</span>
0296                                     <span class="string">'MaxIter'</span>,1000);
0297                                 
0298                                 [X,~,~,~] = lsqnonlin(@(X)<a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam),x0,lb,ub,options);
0299                                 [~,~,ig,~] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam);
0300                                 
0301                                 <span class="keyword">if</span> useW
0302                                     <span class="comment">% normalize the fit because the signal was error</span>
0303                                     <span class="comment">% weighted for the inversion</span>
0304                                     e = diag(iparam.W);
0305                                     einv = 1./e;
0306                                     Winv = diag(einv);
0307                                     ig = Winv * ig;
0308                                 <span class="keyword">end</span>
0309                         
0310                                 residual = ig - g';
0311                                 iF = X(1:length(X)-1);
0312                                 
0313                                 <span class="comment">% output data</span>
0314                                 <span class="comment">% get RMS and X^2</span>
0315                                 <span class="keyword">if</span> useW
0316                                     <span class="comment">% weighted RMS error</span>
0317                                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0318                                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0319                                     RMS(i) = sqrt (sum(N'.*(residual).^2) / length(residual));
0320                                     <span class="comment">% X2 estimate</span>
0321                                     CHI2(i) = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0322                                 <span class="keyword">else</span>
0323                                     <span class="comment">% RMS error</span>
0324                                     RMS(i) = sqrt( sum(residual.^2) / length(residual) );
0325                                     <span class="comment">% X2 estimate</span>
0326                                     CHI2(i) = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0327                                 <span class="keyword">end</span>
0328                                 <span class="comment">% error norm and model norm</span>
0329                                 RN(i) = norm(residual,2);
0330                                 XN(i) = norm(L*iF',2);
0331                                 <span class="comment">% wait-bar update</span>
0332                                 <span class="keyword">if</span> wbopts.show
0333                                     waitbar(i / steps,hwb,[<span class="string">'processing ...'</span>,num2str(i),<span class="string">' / '</span>,num2str(steps),<span class="string">' lambda steps'</span>]);
0334                                 <span class="keyword">end</span>
0335                             <span class="keyword">end</span>
0336                         <span class="keyword">end</span>                        
0337                         <span class="comment">% delete the wait-bar</span>
0338                         <span class="keyword">if</span> wbopts.show
0339                             delete(hwb);
0340                         <span class="keyword">end</span>
0341                         
0342                         <span class="comment">% check if the STOP button was pressed</span>
0343                         <span class="comment">% if &quot;UserData&quot; is 1 STOP was not pressed -&gt; save data</span>
0344                         <span class="keyword">if</span> get(gui.push_handles.invjoint_run,<span class="string">'UserData'</span>) == 1
0345                             lc.lambda = lambda_range;
0346                             lc.RMS = RMS;
0347                             lc.RN = RN;
0348                             lc.XN = XN;
0349                             <span class="comment">% get optimal lambda</span>
0350 <span class="comment">%                             lc.index = getLambdaFromRMS(lc.lambda,lc.RMS,0);</span>
0351                             lc.index = <a href="../../../nucleus/functions/inversion/getLambdaFromLCurve.html" class="code" title="function index = getLambdaFromLCurve(rho,eta,plotit)">getLambdaFromLCurve</a>(RN,XN,0);
0352                             data.results.lcurve = lc;
0353                             <span class="comment">% update GUI data</span>
0354                             setappdata(fig,<span class="string">'data'</span>,data);
0355                             <span class="comment">% update L-curve plots</span>
0356                             <a href="updatePlotsLcurve.html" class="code" title="function updatePlotsLcurve">updatePlotsLcurve</a>;
0357                             <span class="comment">% status bar information</span>
0358                             <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">' done'</span>]);
0359                             <span class="comment">% set focus on results</span>
0360                             set(gui.plots.DistPanel,<span class="string">'Selection'</span>,1);
0361                         <span class="keyword">else</span>
0362                             <span class="comment">% status bar information</span>
0363                             <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">' was canceled'</span>]);
0364                             <span class="comment">% remove temporary data fields</span>
0365                             data = <a href="removeInversionFields.html" class="code" title="function data = removeInversionFields(data)">removeInversionFields</a>(data);
0366                         <span class="keyword">end</span>
0367                         
0368                     <span class="keyword">case</span> <span class="string">'manual'</span>
0369                         <span class="comment">% disable the RUN button to indicate a running inversion</span>
0370                         set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0371                             <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);  
0372             
0373                         <span class="comment">% inversion parameter</span>
0374                         iparam.t = t;
0375                         iparam.g = g;
0376                         <span class="keyword">if</span> useW
0377                             iparam.W = W;
0378                         <span class="keyword">end</span>
0379                         iparam.Tb = data.invstd.Tbulk;
0380                         iparam.T1T2 = T1T2flag;
0381                         iparam.T1IRfac = T1IRfac;
0382                         iparam.L = L;
0383                         iparam.lambda = data.invjoint.lambda;
0384                         iparam.igeom = igeom;
0385                         iparam.IPS = IPS;
0386                         iparam.SVdata = SVdata;
0387                         iparam.SatImbDrain = SatImbDrain;
0388                         
0389                         <span class="comment">% start values and bounds</span>
0390                         x0 = [zeros(size(igeom.radius))' log10(1e-6)];
0391                         lb = [zeros(size(igeom.radius))' log10(1e-8)];
0392                         ub = [ones(size(igeom.radius))' log10(1e-3)];
0393                         
0394                         <span class="comment">% status bar information</span>
0395                         infostring = <span class="string">'Joint Inversion (free) using ''lsqnonlin'' ... '</span>;
0396                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0397                         
0398                         <span class="comment">% optimization settings</span>
0399                         options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0400                             <span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'FinDiffType'</span>,<span class="string">'central'</span>,<span class="keyword">...</span>
0401                             <span class="string">'Algorithm'</span>,<span class="string">'levenberg-marquardt'</span>,<span class="keyword">...</span>
0402                             <span class="string">'MaxIter'</span>,1000);
0403                         [X,~,~,exitflag] = lsqnonlin(@(X)<a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam),x0,lb,ub,options);
0404                         <span class="comment">% status bar information</span>
0405                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0406                         <span class="comment">% get the final fit</span>
0407                         [~,~,ig,KK] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam);
0408                         
0409                         <span class="keyword">if</span> useW
0410                             <span class="comment">% normalize the fit because the signal was error</span>
0411                             <span class="comment">% weighted for the inversion</span>
0412                             e = diag(iparam.W);
0413                             einv = 1./e;
0414                             Winv = diag(einv);
0415                             ig = Winv * ig;
0416                         <span class="keyword">end</span>
0417                 
0418                         <span class="comment">% the inverted surface relaxivity and PSD</span>
0419                         iF = X(1:length(X)-1);
0420                         irho = 10^X(length(X));
0421                         <span class="comment">% inversion output</span>
0422                         data.results.invjoint.p0 = p0;
0423                         data.results.invjoint.S0 = S0;
0424                         data.results.invjoint.levels = levels;
0425                         data.results.invjoint.T1T2 = T1T2flag;
0426                         data.results.invjoint.T1IRfac = T1IRfac;
0427                         data.results.invjoint.x0 = x0;
0428                         data.results.invjoint.lb = lb;
0429                         data.results.invjoint.ub = ub;
0430                         data.results.invjoint.iparam = iparam;
0431                         data.results.invjoint.iGEOM = igeom;
0432                         data.results.invjoint.iSAT = iSAT;
0433                         data.results.invjoint.iF = iF';
0434                         data.results.invjoint.irho = irho;
0435                         data.results.invjoint.ig = ig;
0436                         data.results.invjoint.XX = KK;
0437                         data.results.invjoint.errnorm = norm((ig - g')).^2;
0438                         data.results.invjoint.residual = ig - g';
0439                         data.results.invjoint.exitflag = exitflag;
0440                         
0441                         <span class="comment">% get RMS and X^2</span>
0442                         residual = data.results.invjoint.residual;
0443                         <span class="keyword">if</span> useW
0444                             <span class="comment">% weighted RMS error</span>
0445                             <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0446                             <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0447                             data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0448                             <span class="comment">% X2 estimate</span>
0449                             data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0450                         <span class="keyword">else</span>
0451                             <span class="comment">% RMS error</span>
0452                             data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0453                             <span class="comment">% X2 estimate</span>
0454                             data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0455                         <span class="keyword">end</span>
0456                                                 
0457                         <span class="comment">% predict CPS curves for the final model</span>
0458                         infostring = <span class="string">'calculate CPS curve ... '</span>;
0459                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0460                         ppsddata.r = igeom.radius';
0461                         ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0462                         <span class="keyword">if</span> min(p) == 0
0463                             p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0464                         <span class="keyword">else</span>
0465                             p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0466                         <span class="keyword">end</span>
0467                         pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(igeom,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0468                         <span class="comment">% save</span>
0469                         data.results.invjoint.pSAT = pSAT;
0470                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]); 
0471                 <span class="keyword">end</span>
0472                 
0473             <span class="keyword">case</span> <span class="string">'fixed'</span> <span class="comment">% only invert for rho</span>
0474                 <span class="comment">% disable the RUN button to indicate a running inversion</span>
0475                 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0476                     <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0477                 
0478                 <span class="comment">% inversion geometry</span>
0479                 igeom.type = data.invjoint.geometry_type;
0480                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0481                 igeom.polyN = data.invjoint.polyN;
0482                 igeom.radius = data.param.rho.*data.param.a.*fullsat.T; <span class="comment">% first guess</span>
0483                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0484                 
0485                 iparam.t = t;
0486                 iparam.g = g;
0487                 <span class="keyword">if</span> useW
0488                     iparam.W = W;
0489                 <span class="keyword">end</span>
0490                 iparam.indt = indt;
0491                 iparam.Tb = data.invstd.Tbulk;
0492                 iparam.T1T2 = T1T2flag;
0493                 iparam.T1IRfac = T1IRfac;
0494                 iparam.SatImbDrain = SatImbDrain;
0495                 iparam.p = p;
0496                 iparam.igeom = igeom;
0497                 iparam.x = fullsat.T';
0498                 iparam.f = fullsat.F';
0499                 
0500                 <span class="comment">% start values</span>
0501                 x0 = log10(data.invjoint.rhostart/1e6);
0502                 lb = log10(1e-8);
0503                 ub = log10(1e-3);
0504                 
0505                 infostring = <span class="string">'Joint Inversion (fixed) using ''fminsearchbnd'' ... '</span>;
0506                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0507                 
0508                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0509                     <span class="string">'MaxFunEvals'</span>,300,<span class="string">'MaxIter'</span>,300);
0510                 X = fminsearchbnd(@(X) <a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>(X,iparam),x0,lb,ub,options);
0511                 
0512                 [errnorm,ig,XX,iGEOM,iSAT] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>(X,iparam);
0513                 
0514                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0515                 
0516                 <span class="keyword">if</span> useW
0517                     <span class="comment">% normalize the fit because the signal was error</span>
0518                     <span class="comment">% weighted for the inversion</span>
0519                     e = diag(iparam.W);
0520                     einv = 1./e;
0521                     Winv = diag(einv);
0522                     ig = Winv * ig;
0523                 <span class="keyword">end</span>                
0524                 
0525                 <span class="comment">% inverted surface relaxivity</span>
0526                 irho = 10^X(1);
0527                 <span class="comment">% output data</span>
0528                 data.results.invjoint.p0 = p0;
0529                 data.results.invjoint.S0 = S0;
0530                 data.results.invjoint.levels = levels;
0531                 data.results.invjoint.T1T2 = T1T2flag;
0532                 data.results.invjoint.T1IRfac = T1IRfac;
0533                 data.results.invjoint.x0 = x0;
0534                 data.results.invjoint.lb = lb;
0535                 data.results.invjoint.ub = ub;
0536                 data.results.invjoint.iparam = iparam;
0537                 data.results.invjoint.iGEOM = iGEOM;
0538                 data.results.invjoint.iSAT = iSAT;
0539                 data.results.invjoint.iF = fullsat.F;
0540                 data.results.invjoint.irho = irho;
0541                 data.results.invjoint.ig = ig;
0542                 data.results.invjoint.XX = XX;
0543                 data.results.invjoint.errnorm = errnorm;
0544                 data.results.invjoint.residual = ig-g';
0545                 
0546                 <span class="comment">% get RMS and X^2</span>
0547                 residual = data.results.invjoint.residual;
0548                 <span class="keyword">if</span> useW
0549                     <span class="comment">% weighted RMS error</span>
0550                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0551                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0552                     data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0553                     <span class="comment">% X2 estimate</span>
0554                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0555                 <span class="keyword">else</span>
0556                     <span class="comment">% RMS error</span>
0557                     data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0558                     <span class="comment">% X2 estimate</span>
0559                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0560                 <span class="keyword">end</span>
0561                 
0562                 <span class="comment">% predict CPS curves from final model</span>
0563                 infostring = <span class="string">'calculate CPS curve ... '</span>;
0564                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0565                 ppsddata.r = iGEOM.radius';
0566                 ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0567                 <span class="keyword">if</span> min(p) == 0
0568                     p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0569                 <span class="keyword">else</span>
0570                     p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0571                 <span class="keyword">end</span>
0572                 <span class="comment">% waitbar option</span>
0573                 wbopts.show = true;
0574                 wbopts.tag = <span class="string">'INV'</span>;
0575                 pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(iGEOM,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0576                 
0577                 data.results.invjoint.pSAT = pSAT;
0578                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0579                 
0580             <span class="keyword">case</span> <span class="string">'shape'</span> <span class="comment">% invert for rho and rectangular shape</span>
0581                 <span class="comment">% disable the RUN button to indicate a running inversion</span>
0582                 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0583                     <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0584                 
0585                 <span class="comment">% inversion geometry</span>
0586                 igeom.type = data.invjoint.geometry_type;
0587                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0588                 igeom.polyN = data.invjoint.polyN;
0589                 igeom.radius = data.param.rho.*data.param.a.*fullsat.T; <span class="comment">% first guess</span>
0590                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0591                 
0592                 iparam.t = t;
0593                 iparam.g = g;
0594                 <span class="keyword">if</span> useW
0595                     iparam.W = W;
0596                 <span class="keyword">end</span>
0597                 iparam.indt = indt;
0598                 iparam.Tb = data.invstd.Tbulk;
0599                 iparam.T1T2 = T1T2flag;
0600                 iparam.T1IRfac = T1IRfac;
0601                 iparam.SatImbDrain = SatImbDrain;
0602                 iparam.p = p;
0603                 iparam.igeom = igeom;
0604                 iparam.x = fullsat.T';
0605                 iparam.f = fullsat.F';
0606                 
0607                 <span class="comment">% scale fit parameter between [0 1]</span>
0608                 <span class="comment">% x0 = [(log10(1e-6)+7)/3 data.invjoint.beta/45];</span>
0609                 <span class="comment">% lb = [(log10(1e-7)+7)/3 0.1/45];</span>
0610                 <span class="comment">% ub = [(log10(1e-4)+7)/3 45/45];</span>
0611                 <span class="comment">% old way</span>
0612                 x0 = [log10(data.invjoint.rhostart/1e6) data.invjoint.anglestart];
0613                 lb = [log10(1e-8) 0.1];
0614                 ub = [log10(1e-3) 45];
0615                 
0616                 infostring = <span class="string">'Joint Inversion (shape) using ''fminsearchbnd'' ... '</span>;
0617                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0618                 options = optimset(<span class="string">'Display'</span>,<span class="string">'iter'</span>,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="string">'MaxIter'</span>,500);
0619                 options.Algorithm = <span class="string">'levenberg-marquardt'</span>;
0620                 options.MaxFunEvals = 500;
0621                 options.DiffMinChange = 1;
0622                 
0623                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-9,<span class="string">'TolX'</span>,1e-9,<span class="keyword">...</span>
0624                     <span class="string">'MaxFunEvals'</span>,300,<span class="string">'MaxIter'</span>,300);
0625                 X = fminsearchbnd(@(X) <a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>(X,iparam),x0,lb,ub,options);
0626                 
0627                 [errnorm,ig,XX,iGEOM,iSAT] = <a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>(X,iparam);
0628                 
0629                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0630                 
0631                 <span class="keyword">if</span> useW
0632                     <span class="comment">% normalize the fit because the signal was error</span>
0633                     <span class="comment">% weighted for the inversion</span>
0634                     e = diag(iparam.W);
0635                     einv = 1./e;
0636                     Winv = diag(einv);
0637                     ig = Winv * ig;
0638                 <span class="keyword">end</span>
0639                 
0640                 irho = 10^X(1);
0641                 ibeta = X(2);
0642                 
0643                 data.results.invjoint.p0 = p0;
0644                 data.results.invjoint.S0 = S0;
0645                 data.results.invjoint.levels = levels;
0646                 data.results.invjoint.T1T2 = T1T2flag;
0647                 data.results.invjoint.T1IRfac = T1IRfac;
0648                 data.results.invjoint.x0 = x0;
0649                 data.results.invjoint.lb = lb;
0650                 data.results.invjoint.ub = ub;
0651                 data.results.invjoint.iparam = iparam;
0652                 data.results.invjoint.iGEOM = iGEOM;
0653                 data.results.invjoint.iSAT = iSAT;
0654                 data.results.invjoint.iF = fullsat.F;
0655                 data.results.invjoint.irho = irho;
0656                 data.results.invjoint.ibeta = ibeta;
0657                 data.results.invjoint.ig = ig;
0658                 data.results.invjoint.XX = XX;
0659                 data.results.invjoint.errnorm = errnorm;
0660                 data.results.invjoint.residual = ig-g';
0661                 
0662                 <span class="comment">% get RMS and X^2</span>
0663                 residual = data.results.invjoint.residual;
0664                 <span class="keyword">if</span> useW
0665                     <span class="comment">% weighted RMS error</span>
0666                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0667                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0668                     data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0669                     <span class="comment">% X2 estimate</span>
0670                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0671                 <span class="keyword">else</span>
0672                     <span class="comment">% RMS error</span>
0673                     data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0674                     <span class="comment">% X2 estimate</span>
0675                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0676                 <span class="keyword">end</span>
0677                 
0678                 <span class="comment">% predict CPS curves from final model</span>
0679                 infostring = <span class="string">'calculate CPS curve ... '</span>;
0680                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0681                 ppsddata.r = iGEOM.radius';
0682                 ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0683                 <span class="keyword">if</span> min(p) == 0
0684                     p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0685                 <span class="keyword">else</span>
0686                     p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0687                 <span class="keyword">end</span>
0688                 <span class="comment">% wait-bar option</span>
0689                 wbopts.show = true;
0690                 wbopts.tag = <span class="string">'INV'</span>;
0691                 pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(iGEOM,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0692                 
0693                 data.results.invjoint.pSAT = pSAT;
0694                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0695         <span class="keyword">end</span>
0696         
0697         <span class="comment">% if the regularization method was not L-curve then post process the</span>
0698         <span class="comment">% NMR data fits</span>
0699         <span class="keyword">if</span> ~strcmp(data.invjoint.regtype,<span class="string">'lcurve'</span>)
0700             <span class="comment">% get the individual NMR fits</span>
0701             <span class="keyword">for</span> i = 1:1:numel(levels)
0702                 idata.nmr{levels(i)}.fit_t = idata.nmr{levels(i)}.t;
0703                 <span class="keyword">if</span> i == 1
0704                     idata.nmr{levels(i)}.fit_g = ig(1:indt(1));
0705                 <span class="keyword">else</span>
0706                     idata.nmr{levels(i)}.fit_g = ig(sum(indt(1:i-1))+1:sum(indt(1:i-1))+indt(i));
0707                 <span class="keyword">end</span>
0708                 residual = idata.nmr{levels(i)}.fit_g - idata.nmr{levels(i)}.g;
0709                 
0710                 <span class="comment">% get RMS and X^2</span>
0711                 <span class="keyword">if</span> useW
0712                     <span class="comment">% weighted RMS error</span>
0713                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0714                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0715                     N = idata.nmr{levels(i)}.N;
0716                     rms = sqrt (sum(N.*(residual).^2) / length(residual));
0717                     <span class="comment">% X2 estimate</span>
0718                     chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(idata.nmr{levels(i)}.g,<span class="keyword">...</span>
0719                         idata.nmr{levels(i)}.fit_g,<span class="keyword">...</span>
0720                         idata.nmr{levels(i)}.e);
0721                 <span class="keyword">else</span>
0722                     <span class="comment">% RMS error</span>
0723                     rms = sqrt( sum(residual.^2) / length(residual) );
0724                     <span class="comment">% X2 estimate</span>
0725                     chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(idata.nmr{levels(i)}.g,<span class="keyword">...</span>
0726                         idata.nmr{levels(i)}.fit_g,<span class="keyword">...</span>
0727                         idata.nmr{levels(i)}.noise);
0728                 <span class="keyword">end</span>
0729 
0730                 idata.nmr{levels(i)}.residual = residual;
0731                 idata.nmr{levels(i)}.rms = rms;
0732                 idata.nmr{levels(i)}.chi2 = chi2;
0733             <span class="keyword">end</span>
0734             <span class="comment">% save the GUI data</span>
0735             data.results.invjoint.idata = idata;
0736             setappdata(fig,<span class="string">'data'</span>,data);
0737             
0738             <span class="comment">% save the &quot;INVdata&quot;</span>
0739             <span class="keyword">for</span> i = 1:1:numel(levels)
0740                 INVdata{levels(i)}.invjoint = data.invjoint;
0741                 INVdata{levels(i)}.pressure = data.pressure;
0742                 INVdata{levels(i)}.results.invjoint = data.results.invjoint;
0743             <span class="keyword">end</span>
0744             setappdata(fig,<span class="string">'INVdata'</span>,INVdata);
0745             <span class="comment">% update the plots</span>
0746             <a href="updatePlotsJointInversion.html" class="code" title="function updatePlotsJointInversion">updatePlotsJointInversion</a>;
0747             <span class="comment">% update the INFO fields</span>
0748             <a href="updateInfo.html" class="code" title="function updateInfo(src,~) %#ok<INUSD>">updateInfo</a>(gui.plots.SignalPanel);            
0749             <span class="comment">% set focus on results</span>
0750             set(gui.plots.SignalPanel,<span class="string">'Selection'</span>,3);
0751             set(gui.plots.DistPanel,<span class="string">'Selection'</span>,3);
0752             <span class="comment">% open INFO field</span>
0753             set(gui.push_handles.info,<span class="string">'String'</span>,<span class="string">'&lt;'</span>);
0754             <a href="../../../nucleus/callbacks/push/onPushShowHide.html" class="code" title="function onPushShowHide(src,~)">onPushShowHide</a>(gui.push_handles.info);
0755         <span class="keyword">end</span>     
0756     <span class="keyword">else</span>        
0757         <span class="keyword">if</span> ~InvtypeIsOK
0758             helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Perform standard multi-exponential inversion first.'</span>,<span class="keyword">...</span>
0759             <span class="string">'For ''fixed'' and ''shape'' you need a RTD!'</span>},<span class="string">'No RTD'</span>);
0760         <span class="keyword">end</span>
0761         <span class="keyword">if</span> ~GatetypeIsOK
0762             helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Check your ''signal gating'' settings.'</span>,<span class="keyword">...</span>
0763             <span class="string">'All signals need to have the same gating.'</span>},<span class="string">'Wrong gating'</span>);
0764         <span class="keyword">end</span>
0765     <span class="keyword">end</span>
0766 <span class="keyword">else</span>
0767     helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Perform standard inversion first.'</span>,<span class="keyword">...</span>
0768         <span class="string">'For ''fixed'' and ''shape'' you need a RTD!'</span>},<span class="string">'No Data'</span>);
0769 <span class="keyword">end</span>
0770 
0771 <span class="comment">%% at the end, no matter what reset the RUN button</span>
0772 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'&lt;HTML&gt;&lt;u&gt;R&lt;/u&gt;UN'</span>,<span class="keyword">...</span>
0773     <span class="string">'BackgroundColor'</span>,<span class="string">'g'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,<span class="string">'Callback'</span>,@<a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>);
0774 setappdata(fig,<span class="string">'gui'</span>,gui);
0775 
0776 <span class="keyword">end</span>
0777 
0778 <span class="comment">%------------- END OF CODE --------------</span>
0779 
0780 <span class="comment">%% License:</span>
0781 <span class="comment">% MIT License</span>
0782 <span class="comment">%</span>
0783 <span class="comment">% Copyright (c) 2018 Thomas Hiller</span>
0784 <span class="comment">%</span>
0785 <span class="comment">% Permission is hereby granted, free of charge, to any person obtaining a copy</span>
0786 <span class="comment">% of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
0787 <span class="comment">% in the Software without restriction, including without limitation the rights</span>
0788 <span class="comment">% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
0789 <span class="comment">% copies of the Software, and to permit persons to whom the Software is</span>
0790 <span class="comment">% furnished to do so, subject to the following conditions:</span>
0791 <span class="comment">%</span>
0792 <span class="comment">% The above copyright notice and this permission notice shall be included in all</span>
0793 <span class="comment">% copies or substantial portions of the Software.</span>
0794 <span class="comment">%</span>
0795 <span class="comment">% THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
0796 <span class="comment">% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
0797 <span class="comment">% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
0798 <span class="comment">% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
0799 <span class="comment">% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
0800 <span class="comment">% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
0801 <span class="comment">% SOFTWARE.</span></pre></div>
<hr><address>Generated by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>